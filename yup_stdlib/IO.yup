import "#std/Errors.yup";
import "#std/Memory.yup";
import "#std/LibC.yup";

File: struct;
#macro CLOSE_SUCC_RESULT() 0:i32;
#macro IO_FILE_NULL() CNullptr:*_IO_FILE;
#macro FILE_NULL() CNullptr:*File;

pub File: struct {
    real_handle: *_IO_FILE;
    name: *i8;
    
    pub new: fnc(const _name: *i8) -> File {
        return File.!{
            .name = _name,
        };
    }

    pub delete: fnc(self) {
        free_memory(cast(self, *void));
        self = #FILE_NULL();
    }

    pub open: fnc(self, const mode: *i8) {
        File::self.real_handle = fopen(File::self.name.*, mode);
        if File::self.real_handle.* == #IO_FILE_NULL() {
            Errors::latest_reason("failed to open file");
            Errors::raise_code(1);
        }
    }

    pub handle: fnc(self) -> *_IO_FILE {
        return File::self.real_handle.*;
    }

    pub close: fnc(self) {
        if fclose(File::self.handle()) != #CLOSE_SUCC_RESULT() {
            Errors::latest_reason("failed to close file");
            Errors::raise_code(1);
        }
    }

    pub override_or_new: fnc(self, const fmt: *i8) {
        File::self.open("w");
        fprintf(File::self.handle(), fmt);
        File::self.close();
    }

    pub append_or_new: fnc(self, const fmt: *i8) {
        File::self.open("a");
        fprintf(File::self.handle(), fmt);
        File::self.close();
    }
}
